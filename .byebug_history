exit
@test.parsed_response
@test
exit
PostTag.where("tag_time > ?", end_date)
exit
new_posts['pagination']['min_tag_id']
new_posts['pagination']['_min_tag_id']
new_posts['pagination']['next_min_tag_id']
new_posts['pagination']
new_posts
exit
new_posts['data'][0]['pointer']
new_posts['data'].each {|x| x['pointer'] = new_posts['pagination']['next_max_tag_id']}
new_posts['pagination']['next_max_tag_id']
new_posts['pagination']
new_posts['data'].each {|x| x['pointer'] = new_posts['pagination']['next_max_tag_id']"}
new_posts['data'][0]['test_thing']
new_posts['data'].each {|x| x['pointer']="new_posts['pagination']['next_max_tag_id']"}
new_posts['data'][0]['test_thing']
new_posts['data'].each {|x| x['test_thing']="it's alive"}
new_posts['data'].each {|x| p x}
new_posts['data']
new_posts
exit
collection[1]
collection[2]
collection[1]
collection[2]
collection[1]
collection[0]
collection
collection['posts']
collection[:posts]
collection[0]
collection
exit
post[:posts]
post[:post]
post[0]
post
exit
all_posts.each {|x| x[:posts].reject {|y| y['created_time'].to_i < start_date}}
all_posts[0][:posts]
all_posts[0].length
all_posts[0]
all_posts
all_posts[0][:posts]
all_posts[0][:posts]['created_time']
all_posts[0][:posts]
all_posts[0][:posts]['created_time']
all_posts.each {|x| x[:posts]['created_time'].to_i < start_date }
all_posts.each {|x| p x}.length
all_posts.each {|x| p x}
all_posts
all_posts.each do |x|
all_posts[5]
all_posts[4]
all_posts[3]
all_posts[2]
all_posts[1]
all_posts[0]
all_posts.flatten
all_posts
all_posts.flatten.length
all_posts.flatten
all_posts.length
all_posts
exit
all_posts[1][:pointer]
all_posts[0][:pointer]
all_posts[1][:pointer]
all_posts[2][:pointer]
all_posts[0][:pointer]
all_posts[0][:posts].length
all_posts[0][:posts]
all_posts[0]['posts']
all_posts[0]
all_posts.length
all_posts
new_posts
new_post
pp
require 'ap'
require 'pp'
exit
next
all_posts.flatten.length
all_posts.flatten
all_posts.length
all_posts.reject{|page| page[:posts]['created_time'].to_i < start_date }
all_posts.reject{|page| page[:posts]['created_time'] }
all_posts.reject{|page| page[:posts] }
all_posts[0][:posts]
all_posts[0]['posts']
all_posts[0][:posts]
all_posts[0]
all_posts[0]['posts']
all_posts[0]
all_posts
exit
new_posts['data'].to_s.include?('AQDOLh197bVUlDUJNkJUA3a8Lc8FBBIr693dxEv61O18L-TWB2zyyAw9S9fjtdqoXbwS7GSBk6g7uzN-cSGZlG6ZfZ51kzM6QOgd-Rv4Lg9mr44hj6AKhXrd0zy2NM6UFY8')
new_posts['data'].to_s.include?('AQBthpgDFBgVzvq6ESZ9UsRQ714LDGkFecpiHgm3hYGZhsspKadB0Pgm48SSy9aqzPToabjQImG1LWl12UwqoKWwb0DsZnMRUTvNp8ElSuNEk8icPijMQF8W6ZgGmOW5KZY')
new_posts['data'].to_s.include?('Hyunsss')
new_posts['data'].to_s.include?('Hyun')
new_posts['data'].to_s.include('Hyun')
new_posts['data'].to_s
new_posts['data'].flatten.flatten
new_posts['data'].flatten
new_posts['data'].include?('users')
new_posts['data'].include?('full_name')
new_posts['data'].include?
new_posts['data']
new_posts['data'][-1]
new_posts['data'][0]
new_posts['data']
new_posts['pagination']
exit
trim = all_posts.flatten(1).reject{|x| x['created_time'].to_i < start_date || x['created_time'].to_i > end_date}exit
trim.length
trim = all_posts.flatten(1).reject{|x| x['created_time'].to_i < start_date || x['created_time'].to_i > end_date}
all_posts.flatten(1).reject{|x| x['created_time'].to_i < start_date || x['created_time'].to_i > end_date}
all_posts.flatten(1).length
exit
all_posts.flatten(1).uniq.length
all_posts.flatten(1).length
all_posts.length
next
exit
all_posts.flatten(1).uniq.count
all_posts.flatten(1).uniq.county
all_posts.flatten(1).uniq
all_posts.flatten(1).length
all_posts.flatten(1)[21]['user']['username']
all_posts.flatten(1)[0]['user']['username']
all_posts.flatten(1)[-1]['user']['username']
next
all_posts.flatten(1)[-1]['user']['username']
next
all_posts.flatten(1)[-1]['user']['username']
next
all_posts.flatten(1)[-1]['user']['username']
exit
posts.parsed_response['data'][0]['created_time']
posts.parsed_response['data'][0]['created_at']
posts.parsed_response['data'][0]
posts.parsed_response['data']
posts.parsed_response.data
posts.parsed_response
posts
posts[0]
posts
exit
JSON.parse(posts.body)['pagination']['next_max_tag_id']
JSON.parse(posts.body)['pagination']
JSON.parse(posts.body)['pagination']['max_tag_id']
JSON.parse(posts.body)['pagination']
JSON.parse(posts.body)
exit
comments['data'].find {|x| x['text'].include?('#'+@hashtag) && x['from']['username'] == post['user']['username']}['created_time']
comments['data'].find {|x| x['text'].include?('#'+@hashtag) && x['from']['username'] == post['user']['username']}
comments['data'].select {|x| x['text'].include?('#'+@hashtag) && x['from']['username'] == post['user']['username']}[0]
comments['data'].select {|x| x['text'].include?('#'+@hashtag) && x['from']['username'] == post['user']['username']}
comments['data'].select {|x| x['text'].include?('#'+@hashtag)}
comments['data']
comments
@hashtag
post
comments['data'].count
comments['data']
comments[:data]
comments.data
comments
exit
HTTParty.get
HTTParty::get
HTTParty::GET
HTTParty::HTTParty
HTTParty.methods
HTTParty.get
HTTParty
httparty
continue
next
!!!
next
exit
comments['data'][0]['from']['username'] == post['user']['username']
comments['data'][0]['from']
comments['data']['from']
comments['data']['from']['username']
comments['data']
comments
comments['data']['user']['username']
comments['data']['from']['username'] == post['user']['username']
comments['data']['text'].include?(post['user']['username'])
comments['data'].count
comments['data']
post['user']['username']
post['user']
post['username']
post.user
post
comments
exit
post['caption']['text'].include?('#'+@hashtag)
post['caption']['text'].include?('##{@hashtag}')
post['caption']['text'].include?('#apitest')
post['caption']['text']
post['caption']
post
exit
done
next
exit
done
next
@parsed_data
exit
@response.each do |x|
@response.each {|x| p 'a' }
@response[0]['user']['username']
response[0]['user']['username']
@response.is_a?(Array)
@response.isA?(Array)
@response.isA(Array)
@response.count
@response.each {|x| p x['user']['username'] }
@response.each {|x| p x['user'] }
@response.each {|x| p x['username'] }
@response.each {|x| p x.username }
@response.each {|x| p x }
@response[0]['user']['username']
@response[0]['user']
@response[0]
@response
exit
@response[0]['type']
@response[0][:type]
@response[0].type
@response[0]
@response
